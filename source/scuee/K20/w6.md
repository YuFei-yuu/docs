# 实验二

| 按键  | 引脚 | 按键  | 引脚  |
| :----: | :----: | :----: |  :----: |
| 上 | PTB17  | A | PTCE2  |
| 左 | PTB16  | B | PTE3   |
| 下 | PTCB11 | C | PTE4   |
| 右 | PTCB10 | D | PTE5   |

## 实验要求

- 基本要求：使用中断方式处理按键，按SW1，LED1红灯亮，按SW2， LED1、LED2红灯亮，按SW3，LED1、LED2、LED3红灯亮，按SW4，LED1、LED2、LED3、LED4红灯亮

- 扩展要求：使用中断方式处理按键，按SW1，LED1红灯亮，按SW2， LED1、LED2红灯亮，按SW3，LED1、LED2、LED3红灯亮，按SW4，LED1、LED2、LED3、LED4红灯亮。并且使用SW5-SW8切换LED的颜色

## 源码

### INKEY.c

```c
#include <derivative.h>

unsigned char  Num[11]={0xA0,0xBE,0x62,0x2A,0x3C,0x29,0x21,0xBA,0x20,0x28,0xFF};
//unsigned long int led[6]={BIT12,BIT13,BIT14,BIT15,BIT16,BIT17};

/*delay function*/
void delayms(unsigned int number)
{
  unsigned short i,j;
  for(i=0;i<number;i++)
  {
	  for(j=0;j<100;j++)
		  asm("nop");
  }
}

/*enable interrupt*/
void enable_irq(int irq)
{
	int div;
	/*Determinate which of the NVICISERs corresponds to the irq */
	div=irq/32;
	switch(div)
	{
	   case  0x0:
		   NVICICPR0=1<<(irq%32);
		   NVICISER0=1<<(irq%32);
		   break;
	   case  0x1:
		   NVICICPR1=1<<(irq%32);
		   NVICISER1=1<<(irq%32);
		   break;
	   case  0x2:
		   NVICICPR2=1<<(irq%32);
		   NVICISER2=1<<(irq%32);
		   break;		   
	}
}

/*enable initial*/
void EN_Init()
{
//	enable_irq(45);  //UART0 interrupt
//	enable_irq(68);  //PIT interrupt
	enable_irq(88);  //PORTB interrupt
	enable_irq(91);  //PORTE interrupt
}

/*KEY initial*/
void KEY_Init()
{
	/*enable PORTA,PORTC,PORTE  clock*/
	SIM_SCGC5|=SIM_SCGC5_PORTB_MASK+SIM_SCGC5_PORTE_MASK;

	/*portB  set to GPIO,raising edge interrupt,no pull enable,passive filter enable*/	
 	PORTB_PCR10=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
	PORTB_PCR11=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;			
	PORTB_PCR16=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
	PORTB_PCR17=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
	
	/*portE  set to GPIO,raising edge interrupt,no pull enable,passive filter enable*/
	PORTE_PCR2=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
	PORTE_PCR3=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
	PORTE_PCR4=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
	PORTE_PCR5=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
	
}
```

### main.c

```c
#include "derivative.h" /* include peripheral declarations */

int main(void)
{
	    SIM_SCGC5=0x2800|SIM_SCGC5_PORTB_MASK|SIM_SCGC5_PORTE_MASK; 
	    
		PORTC_PCR0=0x100;
		PORTC_PCR1=0x100;
		PORTC_PCR2=0x100;
		PORTC_PCR3=0x100;
		PORTC_PCR4=0x100;
		PORTC_PCR5=0x100;
		PORTC_PCR6=0x100;
		PORTC_PCR7=0x100;
		PORTC_PCR8=0x100;
		PORTC_PCR9=0x100;
		PORTC_PCR10=0x100;
		PORTC_PCR11=0x100;
		
		PORTE_PCR2=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
		PORTE_PCR3=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
		PORTE_PCR4=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
		PORTE_PCR5=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;			
		
	 	PORTB_PCR10=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
		PORTB_PCR11=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;			
		PORTB_PCR16=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
		PORTB_PCR17=PORT_PCR_MUX(0X1)+PORT_PCR_IRQC(0X0A)+PORT_PCR_PE_MASK+PORT_PCR_PS_MASK;	
		
		GPIOC_PDDR|= 0xFFF;
		
		GPIOE_PDDR&= ~0x3C;
		GPIOB_PDDR&= ~0x30C00;
		
		GPIOC_PDOR|=0xfff;
		
		KEY_Init();
		EN_Init();

		for(;;){

			int i;
			i=1;
			i=i++;
		}
		
}
```

### Project_Settings\Startup_Code\kinetis_sysinit.c

```c
/*……existing code……*/

void PORTB_Handler()
{
	if(PORTB_ISFR&0X20000){
		colors=0x249<<flag;
		GPIOC_PDOR=~(colors&0x7);
	}
	else if(PORTB_ISFR&0X10000){
		colors=0x249<<flag;
		GPIOC_PDOR=~(colors&0x3F);
	}
	else if(PORTB_ISFR&0X800){
		colors=0x249<<flag;
		GPIOC_PDOR=~(colors&0x1FF);
	}
	else if(PORTB_ISFR&0X400){
		colors=0x249<<flag;
		GPIOC_PDOR=~(colors&0xFFF);
	}
	PORTB_ISFR |= 0x000000FF;
}	

void PORTE_Handler()
{
	if(PORTE_ISFR&0X04){
		flag=0;
	}
	else if(PORTE_ISFR&0X08){
		flag=1;
	}
	else if(PORTE_ISFR&0X10){
		flag=2;
	}
	else if(PORTE_ISFR&0X20){
		flag=0;
	}
	PORTE_ISFR |= 0x000000FF;  //Clear Port E  flags
}

/* The Interrupt Vector Table */
void (* const InterruptVector[])() __attribute__ ((section(".vectortable"))) = {
    /*……existing code……*/
    Default_Handler,
    PORTB_Handler,		//88
    Default_Handler,	//89
    Default_Handler,   //90
    PORTE_Handler,	  //91  PORTE Interrupt 	
    Default_Handler,
    /*……existing code……*/
}

```